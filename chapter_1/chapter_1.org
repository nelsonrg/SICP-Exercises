#+property: header-args:racket :lang sicp
* Exercises
** 1.1

Below is a sequence of expressions.  What is the
result printed by the interpreter in response to each expression?
Assume that the sequence is to be evaluated in the order in which
it is presented.

          10
	  : 10

          (+ 5 3 4)
	  : 12

          (- 9 1)
	  : 8

          (/ 6 2)
	  : 3

          (+ (* 2 4) (- 4 6))
	  : 6

          (define a 3)
	  : 

          (define b (+ a 1))
	  : 

          (+ a b (* a b))
	  : 19

          (= a b)
	  : #f

          (if (and (> b a) (< b (* a b)))
              b
              a)
	  : 4

          (cond ((= a 4) 6)
                ((= b 4) (+ 6 7 a))
                (else 25))
	  : 16

          (+ 2 (if (> b a) b a))
	  : 6

          (* (cond ((> a b) a)
                   ((< a b) b)
                   (else -1))
             (+ a 1))
	  : 16
** 1.4

Observe that our model of evaluation allows for
combinations whose operators are compound expressions.  Use this
observation to describe the behavior of the following procedure:

          (define (a-plus-abs-b a b)
            ((if (> b 0) + -) a b))

The operator is chosen by a conditional. If `b` is positive, it is
added to `a`; otherwise, it is subtracted from `a`. This has the
effect of adding the absolute value of `b` to `a` (as the name would
suggest).

** 1.5

Ben Bitdiddle has invented a test to determine
whether the interpreter he is faced with is using
applicative-order evaluation or normal-order evaluation.  He
defines the following two procedures:

          (define (p) (p))

          (define (test x y)
            (if (= x 0)
                0
                y))

     Then he evaluates the expression

          (test 0 (p))

     What behavior will Ben observe with an interpreter that uses
     applicative-order evaluation?  What behavior will he observe with
     an interpreter that uses normal-order evaluation?  Explain your
     answer.  (Assume that the evaluation rule for the special form
     `if' is the same whether the interpreter is using normal or
     applicative order: The predicate expression is evaluated first,
     and the result determines whether to evaluate the consequent or
     the alternative expression.)

Normal-order: The result would be 0 because the if predicate
statement would evaluate to #t and then the procedure would return 0.

Applicative-order: The procedure will run forever because it cannot
substitute a value for the formal parameter `p`. It will infinitely
recurse as it evaluates `(p)`.
** 1.6

     Alyssa P. Hacker doesn't see why `if' needs to be
     provided as a special form.  "Why can't I just define it as an
     ordinary procedure in terms of `cond'?" she asks.  Alyssa's friend
     Eva Lu Ator claims this can indeed be done, and she defines a new
     version of `if':

          (define (new-if predicate then-clause else-clause)
            (cond (predicate then-clause)
                  (else else-clause)))

     Eva demonstrates the program for Alyssa:

          (new-if (= 2 3) 0 5)
          5

          (new-if (= 1 1) 0 5)
          0

     Delighted, Alyssa uses `new-if' to rewrite the square-root program:

          (define (sqrt-iter guess x)
            (new-if (good-enough? guess x)
                    guess
                    (sqrt-iter (improve guess x)
                               x)))

     What happens when Alyssa attempts to use this to compute square
     roots?  Explain.


`new-if` is a procedure and not a special form so it evaluates each
parameter subexpression before running the procedure. This creates an
infinite recursion because it calls itself in the alternative
expression.

** 1.8

Newton's method for cube roots is based on the
fact that if y is an approximation to the cube root of x, then a
better approximation is given by the value

\[
\frac{\frac{x}{y^2} + 2y}{3}
\]

Use this formula to implement a cube-root procedure analogous to
the square-root procedure.  (In section *Note 1-3-4:: we will see
how to implement Newton's method in general as an abstraction of
these square-root and cube-root procedures.)

#+begin_src racket
;;; Compute the absolute value of x.
;;; This is sufficiently abstracted to be in its own procudure.
(define (abs x)
  (if (>= x 0)
      x
      (- x)))

#|
Compute the cube-root of x using Newton's method.

Note that there are multiple internal procedures that are not
abstracted enough to be taken out of the cube-root scope. These
procedures are tightly coupled to the cube-root procedure. As
mentioned in the book, we will improve the abstraction later.
|#
(define (cube-root x)
  (define tolerance 0.001)
  (define (good-enough? guess x)
    (< (abs (- (expt guess 3)
               x))
       tolerance))
  (define (improve guess x)
    (/ (+ (/ x (expt guess 2))
          (* 2 guess))
       3))
  (define (cube-root-iter guess x)
    (if (good-enough? guess x)
      guess
      (cube-root-iter (improve guess x) x)))
  (cube-root-iter 1.1 x))

(cube-root 125)
#+end_src

#+RESULTS:
: 5.0000004639240965


